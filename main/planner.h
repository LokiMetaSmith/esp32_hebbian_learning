/**
 * @file planner.h
 * @brief Defines the data structures and interfaces for the motion planner.
 *
 * The planner is responsible for finding a sequence of gestures (a plan)
 * to move the robot from a start state to a goal state, optimized for
 * energy efficiency. It uses an A* search algorithm on a graph of gesture tokens.
 */
#ifndef PLANNER_H
#define PLANNER_H

#include "common.h"
#include "main.h"

// --- Gesture Token Definition ---

#define MAX_GESTURE_WAYPOINTS 20

/**
 * @brief Represents a single point in a gesture's trajectory.
 * The content of the waypoint depends on the robot type.
 */
#ifdef ROBOT_TYPE_ARM
typedef struct {
    float positions[ROBOT_DOF];    /**< Target joint positions. */
    float velocities[ROBOT_DOF];   /**< Target joint velocities. */
} GestureWaypoint;
#else // ROBOT_TYPE_OMNI_BASE
typedef struct {
    float velocities[ROBOT_DOF];   /**< Target velocities (vx, vy, v_theta). */
} GestureWaypoint;
#endif

/**
 * @brief Represents a single, learned motion primitive (a "gesture").
 * These are generated by the offline training pipeline.
 */
typedef struct {
    int id;                                     /**< Unique identifier for the gesture. */
    GestureWaypoint waypoints[MAX_GESTURE_WAYPOINTS]; /**< The sequence of waypoints defining the gesture's path. */
    int num_waypoints;                          /**< The number of valid waypoints in the array. */
    float energy_cost;                          /**< The pre-calculated energy cost of executing this gesture. */
    float embedding[HIDDEN_NEURONS];            /**< The embedding representing this gesture in the latent space. */
} GestureToken;


// --- Gesture Graph Definition ---

#define MAX_GESTURE_TOKENS 50 // The size of our gesture vocabulary

/**
 * @brief Represents the complete library of gestures and the costs of transitioning between them.
 */
typedef struct {
    float transition_costs[MAX_GESTURE_TOKENS][MAX_GESTURE_TOKENS]; /**< Adjacency matrix of transition costs. */
    GestureToken gesture_library[MAX_GESTURE_TOKENS];             /**< The array of all learned gesture tokens. */
    int num_tokens;                                               /**< The number of valid tokens in the library. */
} GestureGraph;


// --- Planner Function Prototypes ---

/** @brief The main FreeRTOS task for the motion planner. */
void planner_task(void *pvParameters);

/** @brief Initializes the planner and starts its task. */
void planner_init(void);

/**
 * @brief Sets a new goal for the planner (Local Source).
 * Broadcasts the goal to peers.
 * @param target_pose The target embedding.
 */
void planner_set_goal_internal(const float* target_pose);

/**
 * @brief Sets a new goal for the planner (Network Source).
 * Does NOT broadcast (prevents feedback loops).
 * @param target_pose The target embedding.
 */
void planner_set_goal_network(const float* target_pose);

/** @brief A forward declaration to break a circular dependency with main.c. */
void execute_on_robot_arm(const float* action_vector, int arm_id);

/** @brief Initializes a semaphore used to signal when the planner is idle. */
void planner_init_sync(void);

/** @brief Gives the semaphore to signal that the planner is idle. */
void planner_signal_idle(void);

/** @brief Takes the semaphore to wait for the planner to become idle. */
void planner_wait_for_idle(void);


#endif // PLANNER_H
